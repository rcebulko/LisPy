import unittest
from abc import ABCMeta, abstractmethod
from lisp_exceptions import LispCompilationException
from core import *
from env import *

'''
Abstract syntax trees generated by the lexer; must be compiled
'''

class ASTExpr:
    """Interpreted Lisp abstract syntax tree data type"""
    __metaclass__ = ABCMeta

    @abstractmethod
    # Compile AST into a CExpr
    def compile(self, env):
        pass

'''
ASTs related to booleans
'''

class ASTBool(ASTExpr):
    """Abstract syntax tree for a boolean data type"""
    def __init__(self, state):
        self.state = state

    def __str__(self):
        return repr(self)
    def __repr__(self):
        return "ASTBool(" + str(self.state) + ")"

    def compile(self, deEnv):
        return CBool(self.state)

class ASTIf(ASTExpr):
    """Abstract syntax tree for a conditional datatype"""
    def __init__(self, cond, ifBranch, elseBranch):
        self.cond, self.ifBranch, self.elseBranch = \
            cond, ifBranch, elseBranch

    def __str__(self):
        return repr(self)
    def __repr__(self):
        return "ASTIf(" + \
            str(self.cond) + ", " + \
            str(self.ifBranch) + ", " + \
            str(self.elseBranch) + ")"

    def compile(self, deEnv):
        return CIf(
            self.cond.compile(deEnv),
            self.ifBranch.compile(deEnv),
            self.elseBranch.compile(deEnv)
        )

'''
ASTs related to arithmetic
'''

class ASTNum(ASTExpr):
    """Abstract syntax tree for a number data type"""
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self)
    def __repr__(self):
        return "ASTNum(" + str(self.value) + ")"

    def compile(self, deEnv):
        return CNum(self.value)

'''
ASTs related to cons
'''

class ASTCons(ASTExpr):
    """Abstract syntax tree for a cons datatype"""
    def __init__(self, head, tail):
        self.head, self.tail = head, tail

    def __str__(self):
        return repr(self)
    def __repr__(self):
        return "ASTCons(" + str(self.head) + ", " + str(self.tail) + ")"

    def compile(self, deEnv):
        return CCons(self.head.compile(deEnv), self.tail.compile(deEnv))

class ASTCar(ASTExpr):
    """Abstract syntax tree for a car datatype"""
    def __init__(self, pair):
        self.pair = pair

    def __str__(self):
        return repr(self)
    def __repr__(self):
        return "ASTCar(" + str(self.pair) + ")"

    def compile(self, deEnv):
        # Fix this to make sure cons can be evaluated lazily
        return CCar(self.pair.compile(deEnv))

class ASTCdr(ASTExpr):
    """Abstract syntax tree for a car datatype"""
    def __init__(self, pair):
        self.pair = pair

    def __str__(self):
        return repr(self)
    def __repr__(self):
        return "ASTCdr(" + str(self.pair) + ")"

    def compile(self, deEnv):
        # Fix this to make sure cons can be evaluated lazily
        return CCdr(self.pair.compile(deEnv))

'''
ASTs related to functions
'''

class ASTFun(ASTExpr):
    """Abstract syntax tree for a function datatype"""
    def __init__(self, ids, body):
        # Note: ids must never be empty; that should throw an error in parser
        if type(ids) is not list:
            ids = [ids]
        self.ids, self.body = ids, body

    def __str__(self):
        return repr(self)
    def __repr__(self):
        return "ASTFun(" + str(self.ids) + ", " + str(self.body) + ")"

    def compile(self, deEnv):
        # Curry any multi-argument functions during compilation
        if len(self.ids) == 1:
            # If there is only one argument (base case) compile the body with an
            # environment extended with the argument name
            return CFun(self.body.compile(DeExtend(deEnv, self.ids[0].name)))
        else:
            # If there are multiple, compile recursively
            return ASTFun(
                self.ids[1:],
                ASTFun(
                    [self.ids[0]],
                    self.body
                )
            ).compile(deEnv)

class ASTCall(ASTExpr):
    """Abstract syntax tree for a function invocation data type"""
    def __init__(self, funExpr, argExprs):
        # Note: argExprs must never be empty; that should throw an error in parser
        if type(argExprs) is not list:
            argExprs = [argExprs]
        self.funExpr, self.argExprs = funExpr, argExprs

    def __str__(self):
        return repr(self)
    def __repr__(self):
        return "ASTCall(" + str(self.funExpr) + ", " + str(self.argExprs) + ")"

    def compile(self, deEnv):
        # Function invocation will follow a similar currying pattern as function
        # definitions
        if len(self.argExprs) == 1:
            # If there is only one argument (base case), compilation is easy
            return CCall(
                self.funExpr.compile(deEnv),
                self.argExprs[0].compile(deEnv)
            )
        else:
            # If there are multiple, compile recursively
            return ASTCall(
                ASTCall(
                    self.funExpr,
                    [self.argExprs[0]]
                ),
                self.argExprs[1:]
            ).compile(deEnv)

'''
ASTs related to symbols
'''

class ASTSym(ASTExpr):
    """Abstract syntax tree for an identifier data type"""
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return repr(self)
    def __repr__(self):
        return "ASTId(\"" + str(self.name) + "\")"

    def compile(self, deEnv):
        # Compile the identifier name down into a de-Bruijn index
        return CSym(self.name)

'''
ASTs related to identifiers
'''

class ASTId(ASTExpr):
    """Abstract syntax tree for an identifier data type"""
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return repr(self)
    def __repr__(self):
        return "ASTId(\"" + str(self.name) + "\")"

    def compile(self, deEnv):
        # Compile the identifier name down into a de-Bruijn index
        return CRef(deEnv.lookup(self.name))

'''
ASTs which are purely syntactic sugar; all all converted into already-
implemented ASTs to be compiled
'''

class ASTList(ASTExpr):
    """Abstract syntax tree far a list of expressions"""
    def __init__(self, elements):
        self.elements = elements

    def __str__(self):
        return repr(self)
    def __repr__(self):
        return "ASTList(" + str(self.elements) + ")"

    def compile(self, deEnv):
        if len(self.elements) == 0:
            # In Lisp, '() == nil
            return ASTBool(False).compile(deEnv)
        else:
            return ASTCons(
                self.elements[0],
                ASTList(self.elements[1:])
            ).compile(deEnv)

class ASTWith(ASTExpr):
    """Abstract syntax tree for a local binding"""
    def __init__(self, ids, exprs, body):
        if type(ids) is not list:
            ids = [ids]
        if type(exprs) is not list:
            exprs = [exprs]
        self.ids, self.exprs, self.body = ids, exprs, body

    def __str__(self):
        return repr(self)
    def __repr__(self):
        return "ASTWith(" + \
            str(self.ids) + ", " + \
            str(self.exprs) + ", " + \
            str(self.body) + ")"

    def compile(self, deEnv):
        if len(self.ids) == 1:
            return ASTCall(
                ASTFun(
                    self.ids[0],
                    self.body),
                self.exprs[0]
            ).compile(deEnv)
        else:
            return ASTCall(
                ASTFun(
                    self.ids[0],
                    ASTWith(
                        self.ids[1:],
                        self.exprs[1:],
                        self.body
                    ),
                ),
                self.exprs[0]
            ).compile(deEnv)


class ASTCond(ASTExpr):
    """Abstract syntax tree for a cond branch"""
    def __init__(self, branches):
        self.branches = branches

    def __str__(self):
        return repr(self)
    def __repr__(self):
        return "ASTBind(" + ", ".join(map(str, self.branches)) + ")"

    def compile(self, deEnv):
        first = self.branches[0]
        rest = self.branches[1:]

        elseBranch = ASTBool(False)
        if len(rest) > 0:
            elseBranch = ASTCond(rest)

        return ASTIf(
            first[0],
            first[1],
            elseBranch
        ).compile(deEnv)


'''
Tests!
'''

class ASTTest(unittest.TestCase):
    """Test class for all ASTExpr subclasses"""
    def assertCompilesTo(self, x, y, deEnv):
        return self.assertEqual(x.compile(deEnv), y)

    def setUp(self):
        self.testEnv = DeEnv.fromList(["a", "b", "c", "d", "e"])
        self.emptyEnv = DeEmptyEnv()

    def test_if(self):
        self.assertCompilesTo(
            ASTIf(ASTBool(True),
                ASTNum(5),
                ASTNum(10)
            ),
            CIf(CBool(True),
                CNum(5),
                CNum(10)
            ),
            self.testEnv
        )

    def test_ref(self):
        deEnv = self.testEnv

        self.assertCompilesTo(ASTId("a"), CRef(0), deEnv)
        self.assertCompilesTo(ASTId("c"), CRef(2), deEnv)
        self.assertCompilesTo(ASTId("e"), CRef(4), deEnv)

        exceptCaught = False
        try:
            ASTId("x").compile(deEnv)
        except LispCompilationException, e:
            exceptCaught = True
        self.assertTrue(exceptCaught)

    def test_fun_call(self):
        self.assertCompilesTo(
            ASTCall(
                ASTFun(
                    ASTId("x"),
                    ASTId("x")
                ),
                ASTNum(2)
            ),
            CCall(
                CFun(
                    CRef(0)
                ),
                CNum(2)
            ),
            self.emptyEnv
        )

    def test_list(self):
        deEnv = self.emptyEnv

        self.assertEqual(
            ASTList([ASTNum(1), ASTNum(2), ASTNum(3)]).compile(deEnv),
            ASTCons(ASTNum(1),
                ASTCons(ASTNum(2),
                    ASTCons(ASTNum(3),
                        ASTBool(False)))
            ).compile(deEnv)
        )

if __name__ == "__main__":
    unittest.main()